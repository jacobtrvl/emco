```text
SPDX-License-Identifier: Apache-2.0       
Copyright (c) 2021 Intel Corporation
```

# EMCO Status Notification Framework (experimental)

The EMCO 21.12 release introduces a framework that supports clients to register and receive streaming notifications for instantiated
EMCO resources.  Specically, `Deployment Intent Groups`, `Logical Clouds` and `Cluster Network and Provider Networks`.

This feature is still at an experimental phase and will undergo further development and enhancements in future releases.

# Key Components of the Status Notification Framework

The status notification framework is composed of a number of elements.

1. A gRPC API is defined for registering to receive status notifications.  The API allows a client to register to recieve a couple status types which can be modified for format and filtering options.  The options are essentially the same as the existing EMCO Status Query options.  Refer to [EMCO Resource Lifecycle and Status](Resource_Lifecycle_and_Status.md) for a review of the status query and options.
2. A common status notification server package in the `orchestrator` that can be used by any EMCO microservice that needs to implement a status notification server.  In this release, `orchestrator`, `dcm` and `ncm` implement status notification servers for issuing notifications for `Deployment Intent Groups`, `Logical Clouds` and `Cluster Network and Provider Networks` respectively.
3. Each EMCO microservice that provides a status notification server exposes a gRPC endpoint to which clients may connect.
4. A gRPC client program to register and listen for status notifications.  To illustrate, `emcoctl` has a `watch` command added which implements a gRPC client for the three status notifcation servers.

# Status Notification API

The API is composed of a register and a deregister operation. After registering, the client will receive a string of notifications.
See the gRPC API `proto` file in the repository:  `src/orchestrator/pkg/grpc/statusnotify/statusnotify.proto`

## StatusRegistration

The status registration API takes the following parameters:

1. `clientId` - this is a unique string to be used for each client connection - e.g. a UUID generated by the client
2. `key` - this is one of three sets of key element parameters - for the Deployment Intent Group or Logical Cloud or Cluster.  For example, a Cluster key is comprised of `clusterProvider` and `cluster` whereas the Logical Cloud key is `project` and `logicalCloud`.
3. `statusType` - this will be a value indicating either `Deployed` or `Ready`.  These two types correspond to the status query types of `rsync` and `cluster`.  Meaning has `rsync` _deployed_ the resource(s) to the cluster, and are the resources _ready_ on the cluster.  This parameter indicates the context or source of notifications that will be recieved.
4. `apps` (repeated) - just like the `app` filter in the status query, if a list of apps are provided in the registration, then notifications will be sent only with respect to the identified apps.  By default, all apps are included.
5. `clusters` (repeated) - just like the `cluster` filter in the status query, if a list of clusters are provided in the registration, then notifications will be sent only with respect to the identified clusters.  By default, all clusters are included.
5. `resources` (repeated) - just like the `resource` filter in the status query, if a list of resources are provided in the registration, then notifications will be sent only with respect to the identified resources.  By default, all resources are included.
6. `output` - similar to the `output` parameter of the status query, registration can specify `summary` or `all`.

## StatusNotification

The status notification API provides the following attributes in a notification:

1. `statusValue` - this is the top level status value for the given registration (i.e. subject to registration parameters).  It will have a value of either `READY / NOT READY` or `DEPLOYED / NOT DEPLOYED`
2. `details` - if the registratation specified `format=all`, then the `details` section will provide a list of StatusDetail elements that are appropriate for the specific resource.

### Deployment Intent Group details

The Deployment Intent Group details structure composed of a list of `AppStatus` messages.  Each `AppStatus` is composed of a list of `ClusterStatus` messages.  Each `ClusterStatus` is composed of a list of `ResourceStatus` messages.

Each message at each level of message identifies the specfic element and the relevant status value (e.g. READY / NOT READY).


### Logical Cloud details

In this release, logical cloud only supports `output=summary` notifications.

### Cluster details

The cluster network intents instantiated by `ncm` go to a single cluster and there is no concept of `app`.  So, the notification details consists of a single `ClusterStatus` message which may contain a list of `ResourceStatus` messages.

Because `monitor` does not include information about `Network` and `ProviderNetwork` resources, the `statusType=ready` is not an interesting registration for clusters.

# `emcoctl watch`

The `emcoctl watch` command is added for the three supported EMCO resources.  The registration information is filled out as follows:

1. `clientId` - automatically filled in with a UUID value
2. `key` - is derived from the provided `anchor`
3. `statusType` - provided as either `status=deployed` or `status=ready` (default)
4. `apps` - provided as zero to many arguments of the form `app=vfw`
5. `clusters` - provided as zero to many arguments of the form `cluster=clusterProvider+cluster`
6. `resources` - provided as zero to many arguments of the form `resource=res1`
7. `output` - provided as either `format=summary` (default) or `format=all`

## Example commands

Here are a few example `emcoctl` watch commands:

```
Logical Cloud:
emcoctl --config emco-cfg.yaml watch projects/testvfw/logical-clouds/lcadmin/status status=deployed

Deployment Intent Group:
emcoctl --config emco-cfg.yaml watch projects/testvfw/composite-apps/compositevfw/v1/deployment-intent-groups/vfw_deployment_intent_group/status app=sink format=all resource=fw0-sink-745dd76f97-sjlvm

emcoctl --config emco-cfg.yaml watch projects/testvfw/composite-apps/compositevfw/v1/deployment-intent-groups/vfw_deployment_intent_group/status app=sink format=all status=deployed app=packetgen

Cluster:
emcoctl --config emco-cfg.yaml watch cluster-providers/vfw-cluster-provider/clusters/edge01/status format=all status=deployed
```

# Implementation Notes

The implementation of the status notification is fairly simplistic in this initial release.  The essential flow of operations is as follows:

1. Client registers with an EMCO microservice to receive status notifications (resource must have already been instantiated).
2. Internally, the microservice registers with `rsync` to receive notifications whenever any message from `monitor` for the given resource as been received.
3. Whenever `rsync` gets a message from `monitor` the microservice status notification server makes a status query API call to get the status of the resource.  The status query is called with the same parameters that were supplied by the status notification registration.
4. The status query response is used to prepare a status notification message to be returned to the client.
5. Steps 3-4 are repeated indefinitely.


Because this implementation is simplistic, there are a number of improvements that can be made:

1. `monitor` messages only indicate that a single cluster and app have (potentially) changed.  The status notification server can avoid making status queries that are irrelevant for a given notification registration.  Also the status query only needs to be made for the app and cluster associated with the `monitor` message.
2. No throttling mechanism is implemented.  To handle cases early in an instantiation when many `monitor` messages may be recieved.  It may not be necessary to make status queries on every message.
3. There is currently no checking to verify that a new notification to be sent is different from the previous one sent - i.e. there is no need to send a notification message if it is the same as the previous message sent.
4. Investigate exposure of status notification endpoints when service mesh is installed.
