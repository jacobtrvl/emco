```
SPDX-License-Identifier: Apache-2.0
Copyright (c) 2019-2020 Intel Corporation
```
# Istio Setup with Emco

When clusters are managed by EMCO, each cluster has its own Istio control plane installated, each managing its own endpoints. All of the clusters are under a shared administrative control of EMCO for the purposes of policy enforcement and security.

A single Istio service mesh across the clusters requires using a common root CA in all of the clusters. Cross-cluster communication occurs over the Istio gateways of the respective clusters.

Setup is similar to https://istio.io/v1.7/docs/setup/install/multicluster/gateways/


## Istio Deployment

Istio installation on all clusters managed by EMCO is pre-requisite. EMCO doesn't install Istio but requires Istio installation on managed clusters as described in this section.

Kubernetes clusters with versions: 1.19.

Downlaod Istio verison: 1.10.3

```
ISTIO_VERSION=1.10.3
curl -L https://istio.io/downloadIstio | ISTIO_VERSION=$ISTIO_VERSION sh -

```


Cross cluster communication requires mutual TLS connection between services. To enable mutual TLS communication across clusters, each clusterâ€™s Istio CA will be configured with intermediate CA credentials generated by a shared root CA.


```
 # Create root certificate
 cd istio-1.10.3/tools/certs
 make -f Makefile.selfsigned.mk ROOT_CN="EMCO Root CA" ROOTCA_ORG=project-emco.io root-ca
 # Create Intermediate CA certs for each cluster
 make -f Makefile.selfsigned.mk INTERMEDIATE_CN="EMCO Intermediate CA" INTERMEDIATE_ORG=project-emco.io cluster1-cacerts

 # Apply secrets on first
 kubectl create secret generic cacerts -n istio-system --from-file=cluster1/ca-cert.pem --from-file=cluster1/ca-key.pem --from-file=cluster1/root-cert.pem --from-file=cluster1/cert-chain.pem

 # Create Intermediate cert for each cluster and create secret per cluster

 ```

### Istio installation

Create configuration file like the example:

```
apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
metadata:
  name: istiooperator-config
  namespace: istio-system
spec:
  profile: minimal
  meshConfig:
    # Block all the outbound traffic directly going out by setting the mode to REGISTRY_ONLY
    outboundTrafficPolicy:
      mode: REGISTRY_ONLY
    accessLogFile: /dev/stdout
    enableAutoMtls: true
    defaultConfig:
      proxyMetadata:
        # Enable Istio agent to handle DNS
        ISTIO_META_DNS_CAPTURE: "true"
  components:
    # Enable Istio Ingress gateway
    ingressGateways:
    - name: istio-ingressgateway
      enabled: true
      k8s:
        env:
          - name: ISTIO_META_ROUTER_MODE
            value: "sni-dnat"
        service:
          type: NodePort
          ports:
            - port: 80
              targetPort: 8080
              name: http2
            - port: 443
              targetPort: 8443
              name: https
            - port: 15443
              targetPort: 15443
              name: tls
              nodePort: 32001
  values:
    global:
      pilotCertProvider: istiod
```

Install Istio using the above configuration file:
```
 istioctl install  -f istio-config.yaml

```

## EMCO Istio Cross Cluster Configuration

The following sections provides details on the approach followed by EMCO in automating deployment of Istio resources for the resources that requires cross cluster communication. These sections provides example configurations that are used.

### Example configuration with Sleep and httpbin

To demonstrate cross cluster access, configure the sleep service running in one cluster to call the httpbin service running in a second cluster. One cluster is named cluster1 and the other cluster2.

1. Deploy sleep on cluster1

```
    kubectl create namespace foo
    kubectl label  namespace foo istio-injection=enabled
    kubectl apply  -n foo -f samples/sleep/sleep.yaml
    export SLEEP_POD=$(kubectl get -n foo pod -l app=sleep -o jsonpath={.items..metadata.name})

```

2. Deploy httpbin on cluster2

```
kubectl create namespace bar
kubectl label namespace bar istio-injection=enabled
kubectl apply -n bar -f samples/httpbin/httpbin.yaml

```


3. Create service entry for httpbin on cluster1

```
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
  name: httpbin-bar
  namespace: foo
spec:
  hosts:
  # DNS name selected for the service
  - httpbin.bar.cluster2
  # Treat remote cluster services as part of the service mesh
  # as all clusters in the service mesh share the same root of trust.
  location: MESH_INTERNAL
  ports:
  - name: tcp
    number: 8000
    protocol: TCP
  resolution: DNS
  addresses:
  # the IP address to which httpbin.bar.cluster2 will resolve to
  # must be unique for each remote service, within a given cluster.
  # This address need not be routable. Traffic for this IP will be captured
  # by the sidecar and routed appropriately.
  - 240.0.0.2
  endpoints:
  # This is the routable address of the ingress gateway in cluster2 that
  # sits in front of sleep.foo service. Traffic from the sidecar will be
  # routed to this address.
  - address: 192.168.121.10
    ports:
      tcp: 32001 # Nodeport for istio-ingressgateway for port 15433

```
5. Create DestinationRule for httpbin on cluster1

```
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: httpbin-dr
  namespace: foo
spec:
  host: httpbin.bar.cluster2
  trafficPolicy:
    tls:
      mode: ISTIO_MUTUAL
```

6. On the cluster running httpbin (cluster2) create Gateway resource

```
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: httpbin-gateway
  namespace: istio-system
spec:
  selector:
    istio: ingressgateway
  servers:
    - port:
        number: 15443
        name: tls
        protocol: TLS
      tls:
        mode: AUTO_PASSTHROUGH
      hosts:
        - "httpbin.bar.cluster2"

```

7. Create ServiceEntry on cluster2 that is required to map the remote fqdn to local fqdn:
```
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
  name: httpbin-remote
  namespace: istio-system # must be in same namespace as gateway
spec:
  resolution: DNS
  location: MESH_INTERNAL
  ports:
  - name: tcp
    number: 8000
    protocol: TCP
  exportTo:
  - .
  hosts:
  - "httpbin.bar.cluster2"
  endpoints:
  - address: httpbin.bar.svc.cluster.local

```

8. Create DestinationRule and Virtual Service on cluster2

```
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: httpbin-dr
  namespace: istio-system
spec:
  host: "httpbin.bar.cluster2"
  trafficPolicy:
    tls:
      mode: ISTIO_MUTUAL

```

9. Verify that httpbin is accessible from the sleep service.

```
 kubectl exec $SLEEP_POD -n foo -c sleep -- curl -I httpbin.bar.cluster2:8000/headers

```

### Configure cross-cluster load balancing

This section will show how to configure Istio route rules to call remote services in a multicluster scenario.


1. Create namespace in both clusters

```
kubectl create namespace sample

```

2. Enable automatic sidecar injection for the sample namespace:

```
kubectl label  namespace sample istio-injection=enabled

```

3. Create the HelloWorld service in both clusters:

```
kubectl apply -f samples/helloworld/helloworld.yaml -l service=helloworld -n sample

```

4. Deploy the helloworld-v1 application to cluster1:

```
kubectl apply -f samples/helloworld/helloworld.yaml -l version=v1 -n sample

```

5. Deploy the helloworld-v2 application to cluster2:

```
kubectl apply -f samples/helloworld/helloworld.yaml -l version=v2 -n sample

```

6. Deploy the Sleep in cluster1:

```
kubectl apply -f samples/sleep/sleep.yaml -n sample

```

7. Apply the following configuration in cluster1:

```
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: hello-dr
  namespace: sample
spec:
  host: helloworld.sample.cluster2
  trafficPolicy:
    tls:
      mode: ISTIO_MUTUAL

---
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
  name: helloworld-sample
  namespace: sample
spec:
  hosts:
  # DNS name selected for the service
  - helloworld.sample.cluster2
  # Treat remote cluster services as part of the service mesh
  # as all clusters in the service mesh share the same root of trust.
  location: MESH_INTERNAL
  ports:
  - name: tcp
    number: 5000
    protocol: TCP
  resolution: DNS
  addresses:
  # the IP address to which httpbin.bar.cluster2 will resolve to
  # must be unique for each remote service, within a given cluster.
  # This address need not be routable. Traffic for this IP will be captured
  # by the sidecar and routed appropriately.
  - 240.0.0.3
  endpoints:
  # This is the routable address of the ingress gateway in cluster2 that
  # sits in front of sleep.foo service. Traffic from the sidecar will be
  # routed to this address.
  - address: 192.168.121.10
    ports:
      tcp: 32001 # Nodeport for istio-ingressgateway for port 15433
---

apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: helloworld
  namespace: sample
spec:
  host: helloworld.sample.svc.cluster.local
  trafficPolicy:
    tls:
      mode: ISTIO_MUTUAL

---

apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: helloworld
  namespace: sample
spec:
  hosts:
    - helloworld.sample.svc.cluster.local
  http:
  - route:
    - destination:
        host: helloworld.sample.svc.cluster.local
      weight: 50
    - destination:
        host: helloworld.sample.cluster2
      weight: 50

```

8. Apply this configuration on cluster2

```
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: helloworld-gateway
  namespace: istio-system
spec:
  selector:
    istio: ingressgateway
  servers:
    - port:
        number: 15443
        name: tls
        protocol: TLS
      tls:
        mode: AUTO_PASSTHROUGH
      hosts:
        - "*.sample.cluster2"

---
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
  name: helloworld-remote
  namespace: istio-system # must be in same namespace as gateway
spec:
  resolution: DNS
  location: MESH_INTERNAL
  ports:
  - name: tcp
    number: 5000
    protocol: TLS
  exportTo:
  - .
  hosts:
  - "helloworld.sample.cluster2"
  endpoints:
  - address: helloworld.sample.svc.cluster.local

---
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: helloworld-remote
  namespace: istio-system
spec:
  host: "helloworld.sample.cluster2"
  trafficPolicy:
    tls:
      mode: ISTIO_MUTUAL

```
9. Verify cross-cluster load balancing
To verify that cross-cluster load balancing works as expected, call the HelloWorld service several times using the Sleep pod in cluster1.

```
kubectl exec -n sample -c sleep "$(kubectl get pod -n sample -l app=sleep -o jsonpath='{.items[0].metadata.name}')" -- curl -sS helloworld.sample:5000/hello

```

Repeat this request several times and verify that the HelloWorld version should toggle between v1 and v2:

```
Hello version: v2, instance: helloworld-v2-758dd55874-6x4t8
Hello version: v1, instance: helloworld-v1-86f77cd7bd-cpxhv
```
### Example configuration httpbin cluster external access using mutual tls

# Install httpbin app
```shell
$ curl -L https://istio.io/downloadIstio | ISTIO_VERSION=1.10.3 TARGET_ARCH=x86_64 sh -
$ kubectl apply -f istio-1.10.3/samples/httpbin/httpbin.yaml
```

# Create root cert and private key
```shell
$ openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -subj '/O=example Inc./CN=example.com' -keyout example.com.key -out example.com.crt
```

# Create certificate and private key for httpbin.example.com
```shell
openssl req -out httpbin.example.com.csr -newkey rsa:2048 -nodes -keyout httpbin.example.com.key -subj "/CN=httpbin.example.com/O=httpbin organization"
openssl x509 -req -sha256 -days 365 -CA example.com.crt -CAkey example.com.key -set_serial 0 -in httpbin.example.com.csr -out httpbin.example.com.crt
```

# Create client certificate and private key
```shell
openssl req -out client.example.com.csr -newkey rsa:2048 -nodes -keyout client.example.com.key -subj "/CN=client.example.com/O=client organization"
openssl x509 -req -sha256 -days 365 -CA example.com.crt -CAkey example.com.key -set_serial 1 -in client.example.com.csr -out client.example.com.crt
```

# Create secret
```shell
kubectl create -n istio-system secret generic httpbin-credential --from-file=tls.key=httpbin.example.com.key \
--from-file=tls.crt=httpbin.example.com.crt --from-file=ca.crt=example.com.crt
```

# Create gateway
```shell
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: mygateway
spec:
  selector:
    istio: ingressgateway # use istio default ingress gateway
  servers:
  - port:
      number: 443
      name: https
      protocol: HTTPS
    tls:
      mode: MUTUAL
      credentialName: httpbin-credential # must be the same as secret
    hosts:
    - httpbin.example.com
```

# Create virtual service
```shell
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: httpbin
spec:
  hosts:
  - "httpbin.example.com"
  gateways:
  - mygateway
  http:
  - match:
    - port: 443
    route:
    - destination:
        port:
          number: 8000
        host: httpbin
```

# Curl from outside the cluster
NOTE: Get the ingress port and host address from the cluster
```shell
curl -v -HHost:httpbin.example.com --resolve "httpbin.example.com:$SECURE_INGRESS_PORT:$INGRESS_HOST" \
--cacert example.com.crt --cert client.example.com.crt --key client.example.com.key \
"https://httpbin.example.com:$SECURE_INGRESS_PORT/status/418"
```

# Expected output
```shell
* Added httpbin.example.com:30830:172.16.16.200 to DNS cache
* Hostname httpbin.example.com was found in DNS cache
*   Trying 172.16.16.200...
* TCP_NODELAY set
* Connected to httpbin.example.com (172.16.16.200) port 30830 (#0)
* ALPN, offering h2
* ALPN, offering http/1.1
* successfully set certificate verify locations:
*   CAfile: ../example.com.crt
  CApath: /etc/ssl/certs
* TLSv1.3 (OUT), TLS handshake, Client hello (1):
* TLSv1.3 (IN), TLS handshake, Server hello (2):
* TLSv1.3 (IN), TLS Unknown, Certificate Status (22):
* TLSv1.3 (IN), TLS handshake, Unknown (8):
* TLSv1.3 (IN), TLS handshake, Request CERT (13):
* TLSv1.3 (IN), TLS handshake, Certificate (11):
* TLSv1.3 (IN), TLS handshake, CERT verify (15):
* TLSv1.3 (IN), TLS handshake, Finished (20):
* TLSv1.3 (OUT), TLS change cipher, Client hello (1):
* TLSv1.3 (OUT), TLS Unknown, Certificate Status (22):
* TLSv1.3 (OUT), TLS handshake, Certificate (11):
* TLSv1.3 (OUT), TLS Unknown, Certificate Status (22):
* TLSv1.3 (OUT), TLS handshake, CERT verify (15):
* TLSv1.3 (OUT), TLS Unknown, Certificate Status (22):
* TLSv1.3 (OUT), TLS handshake, Finished (20):
* SSL connection using TLSv1.3 / TLS_AES_256_GCM_SHA384
* ALPN, server accepted to use h2
* Server certificate:
*  subject: CN=httpbin.example.com; O=httpbin organization
*  start date: Feb 22 16:36:41 2022 GMT
*  expire date: Feb 22 16:36:41 2023 GMT
*  common name: httpbin.example.com (matched)
*  issuer: O=example Inc.; CN=example.com
*  SSL certificate verify ok.
* Using HTTP2, server supports multi-use
* Connection state changed (HTTP/2 confirmed)
* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0
* TLSv1.3 (OUT), TLS Unknown, Unknown (23):
* TLSv1.3 (OUT), TLS Unknown, Unknown (23):
* TLSv1.3 (OUT), TLS Unknown, Unknown (23):
* Using Stream ID: 1 (easy handle 0x55f9e4bcb620)
* TLSv1.3 (OUT), TLS Unknown, Unknown (23):
> GET /status/418 HTTP/2
> Host:httpbin.example.com
> User-Agent: curl/7.58.0
> Accept: */*
>
* TLSv1.3 (IN), TLS Unknown, Certificate Status (22):
* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):
* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):
* TLSv1.3 (IN), TLS Unknown, Unknown (23):
* Connection state changed (MAX_CONCURRENT_STREAMS updated)!
* TLSv1.3 (OUT), TLS Unknown, Unknown (23):
* TLSv1.3 (IN), TLS Unknown, Unknown (23):
< HTTP/2 418
< server: istio-envoy
< date: Wed, 23 Feb 2022 15:23:57 GMT
< x-more-info: http://tools.ietf.org/html/rfc2324
< access-control-allow-origin: *
< access-control-allow-credentials: true
< content-length: 135
< x-envoy-upstream-service-time: 15
<

    -=[ teapot ]=-

       _...._
     .'  _ _ `.
    | ."` ^ `". _,
    \_;`"---"`|//
      |       ;/
      \_     _/
        `"""`
* Connection #0 to host httpbin.example.com left intact
```

# Example connecting to external mysql database from the EMCO managed cluster

## Start the mysql server on the host

```
sudo apt update
sudo apt install mysql-server
sudo systemctl start mysql.service
```
## Build mysql client image
```
export DOCKER_REG=<docker reg>
cd examples/test-apps/mysql
./mysql-build.sh
```
## Create mysql client on the cluster
```
cd ../../helm_charts/mysql-client/helm/mysql
helm install mysql .
```
### Apply the following service entry

```
apiVersion: networking.istio.io/v1beta1
kind: ServiceEntry
metadata:
  name: external-svc-mysql
spec:
  hosts:
  # hostname where the mysql server is running
  - <hostname>
  addresses:
  # vip for this service entry, traffic for this IP will be captured
  # by the sidecar and routed appropriately.
  - 240.0.0.4
  ports:
  - number: 3306
    name: mysql
    protocol: TCP
  location: MESH_EXTERNAL
  resolution: STATIC
  # The endpoint address points to the ip address of the mysql server
  endpoints:
  - address: 172.25.55.65
```
## Create http client on the cluster
```
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
  name: nginx-ext
spec:
  hosts:
  - <hostname>
  addresses:
  - <vip address>
  ports:
  - number: 80
    name: http
    protocol: HTTP
  location: MESH_EXTERNAL
  resolution: STATIC
  endpoints:
  - address: 172.25.55.65
```

## Create https client on the cluster
```
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
  name: google
spec:
  hosts:
  - www.google.com
  ports:
  - number: 443
    name: https
    protocol: HTTPS
  resolution: DNS
  location: MESH_EXTERNAL
```
